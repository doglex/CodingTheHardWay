[TOC]

### 操作系统
是指控制和管理整个计算机系统的**硬件**和**软件**资源，<br>
并合理地组织**调度**计算机的工作和资源的分配，<br>
以提供给用户和其他软件方便的**接口**和**环境**，<br>
是计算机系统中最基本的**系统软件**。

### 操作系统的功能和目标

1. 作为系统资源的管理者<br>
功能:
    + 处理机管理
    + 存储器管理
    + 文件管理
    + 设备管理<br>
目标:高效、安全
2. 作为用户和硬件直接的接口<br>
功能：命令接口(联机命令逐个做，脱机命令做一批)、程序接口(比如dll)、GUI (Graphical User Interface) 
> 命令接口是说直接调用；`程序接口`是说可以`间接使用`，当然是由一堆`系统调用`组成的 😳<br> 
> `系统调用` = `广义指令` 👎

3.对硬件扩展

### 操作系统四大特征
`并发`和`共享`(两个基本，互为条件)， `虚拟`, `异步`
> 并发(concurrency)：多个事件在同一时间`间隔`发生。宏观上(逻辑上)同时发生，微观上(物理上)交错发生 <br>
> 并行(parallelism)：多个时间在同一时间`同时`（物理上）发生。 `那是说要多核了啊，对一个核而言只处理一件事`🤣

+ `并发`：允许多个程序在(交替或并行)运行，即`多道程序技术` 
+ `共享`：互斥共享(独占资源)、(宏观上)同时共享 
+ `虚拟`：物理实体对应到逻辑实体： 比如空分复用(虚拟内存)、时分复用(虚拟CPU搞并发)
+ `异步`：有多个程序并发的时候，对于程序的小片段相对另一个程序来说执行顺序不可预先确定。可以阻塞、可以释放

> 因为业务上有太多时间容忍度很小的事件。事件驱动

### 操作系统的历史
+ 手工操作阶段：纸带机, 用户独占全机、人机速度矛盾导致资源利用率低
+ 单道批处理阶段： 磁盘机+外围机，脱机输入输出，`监督程序`（操作系统雏形）控制I/O :只能串行、大量IO阻塞
+ 多道批处理阶段：交替执行，引入`中断`功能(IO与计算之间可以不相互阻塞了，设备间并行了)，`操作系统诞生`😥。：虽然能并发，但是没法人机`交互`，你要等他这个程序跑完或报错
+ 分时操作系统：时间片轮流服务，那么轮到你的时间片的时候就可以`交互`了，你可以告诉他我这个程序要关掉：但是时间片是公平的，不能`优先处理紧急任务`
+ 实时操作系统：`紧急任务`的时间片可以"插队"，更加及时可靠。比如导弹的硬实时系统、而软实时系统的紧急事件等一等也没事
+ 网络操作系统、分布式操作系统、个人计算机操作系统



### 操作系统运行机制和架构

> `指令` 和`代码`的区别？ C语言代码可能翻译成多条机器语言 (二进制)指令，可以被CPU 具体识别。
+ 特权指令：不允许用户程序使用。比如内存清零指令、访问硬件等。
+ 非特权指令：比如普通的运算。

> PSW(程序状态字寄存器)中某个标志位表示CPU状态。
+ CPU处于`用户态`时只能执行非特权指令。
+ CPU处于`核心态`时都可以执行。

> (普通)`应用程序`为了安全，只能用非特权指令。 比如记事本、任务管理器，不是内核功能。

> `内核`(内核程序) 可以执行两种指令，运行在核心态。因此，用了核心态的功能的程序就是内核程序。 比如时钟管理、原语程序(具有原子性，即要么执行要么不执行)、中断处理程序。

> 有的操作系统把进程管理、存储器管理、设备管理也算内核。(如果算，就称为`宏内核`， 否则就是`微内核`)

> `宏内核`：代码庞大、性能高；`微内核`：代码少，需要频繁在核心态和用户态之间切换。


### (外)中断和(内中断)异常
> 解决资源串行利用率低的问题。需要中断来并发执行。

> CPU收到计时部件的`中断信号`，（立刻）切换为`核心态`,让操作系统介入管理,操作系统会对不同的信号做不同处理。

> 从用户态→核心态只能通过中断实现。而核心态→用户态只需要改PSW。

> 外中断：外设请求、人工干预。(信号来自CPU外部)

> 内中断(异常、例外、陷入)：自愿中断(指令中断)，强迫中断(硬件故障，比如缺页、软件中断，比如除0)。


### 系统调用
> 为什么提供系统调用？ 避免每个进程随意使用资源、需要OS进行协调管理一些公共的函数， 保证稳定性和安全性。
一般需要特权指令、在核心态下完成

+ 设备：请求/释放/启动
+ 文件：读/写/创建/删除
+ 进程: 创建/撤销/阻塞/唤醒/信号传递/信息传递
+ 内存: 分配/回收


### 进程

程序：一个指令序列。<br>
`进程`(Process):`资源分配的基本单元`， 被CPU调度的单元，就是程序的一次执行。 `进程实体`由程序段、数据段、PCB组成。PCB是进程唯一存在标志。<br>
`线程`(Thread):`CPU调度的基本单元`。 

> PCB(进程控制块):里面会有记各个寄存器的值，下次轮到执行时可以恢复。进程本身是动态的，进程实体里存了静态的数据。

> 操作系统的`执行指针`：指向当前执行的PCB;`就绪表指针`，指向就绪PCB列表；`阻塞表指针`，指向阻塞的PCB列表。

进程特征：
+ 动态性
+ 并发性： 并发结果会不确定。需要操作系统提供`进程同步`来保证。
+ 独立性
+ 异步性
+ 结构性

#### 进程的状态转化

三种基本状态：(看拥有的资源可以知道是什么状态)
+ 运行态(Running)：独占CPU(一个核)
+ 就绪态(Ready):具备运行条件，`只差CPU`
+ 阻塞态(Blocked/Waiting):还差`其他资源/事件`条件，暂时不能运行

两种额外状态：
+ 创建态： 正在分配资源，初始化PCB
+ 终止态： 正在回收资源，销毁PCB

转换：
+ 创建态 → 就绪态 → 运行态
+ 运行态 → 就绪态：时间片到、或被抢占
+ 运行态 → 阻塞态：（主动）“系统调用”等待资源、等待事件
+ 阻塞态 → 就绪态：（被动）资源好了，等待CPU
> 不能阻塞态直接到运行态的，也不能就绪态到阻塞态的 （书上是这么说）

#### 进程控制：就是实现进程状态转换
PCB用于保存/恢复进程环境、记录标志位、排队<br>
用`原语`(即`原子操作`，只能一气呵成，需要运行在`核心态`)实现控制.先`关中断`，完成后`开中断`实现了原子操作，外部中断信号会被临时屏蔽。
<br>原语做三件事：更新PCB、插PCB到合适队列、分配/回收资源。
+ 进程创建(创建原语)：用户登录、作业调度、提供服务、应用请求(子进程)
+ 进程终止(撤销原语):正常结束、异常结束(比如div 0)、外界干预
+ 进程阻塞(阻塞原语)：等待资源(比如IO)、等待其他进程
+ 进程唤醒(唤醒原语): 等待的事件(被阻塞的事件)发生


#### 进程通信：进程间交换信息
进程是分配资源的基本单位，(为了安全)各进程的内存空间独立(不能直接相互访问)
+ `共享存储`：(互斥的访问，操作系统提供PV)共享空间：包括`共享存储结构`、`共享存储区`(速度更快)
+ `管道通信`：基于(互斥的)共享文件，即在内存中开辟缓冲区。管道只能`半双工`(一个时间内单向)。可以做两个管道同时两个方向。
管道满了后write()要等待读进程的read()，空了等write()。没写满不能读，没读空不嫩写。一旦取出就没了，`因此只能被一个进程读`。
+ `消息传递`：通过`格式化的消息`(消息头+消息体)，操作系统提供发送原语/接收原语。直接通信，可以直接挂在接收进程的消息缓重队列。间接通信，需要通过中间的信箱。


