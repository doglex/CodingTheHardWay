[TOC]

### 操作系统
是指控制和管理整个计算机系统的**硬件**和**软件**资源，<br>
并合理地组织**调度**计算机的工作和资源的分配，<br>
以提供给用户和其他软件方便的**接口**和**环境**，<br>
是计算机系统中最基本的**系统软件**。

### 操作系统的功能和目标

1. 作为系统资源的管理者<br>
功能:
    + 处理机管理
    + 存储器管理
    + 文件管理
    + 设备管理<br>
目标:高效、安全
2. 作为用户和硬件直接的接口<br>
功能：命令接口(联机命令逐个做，脱机命令做一批)、程序接口(比如dll)、GUI (Graphical User Interface) 
> 命令接口是说直接调用；`程序接口`是说可以`间接使用`，当然是由一堆`系统调用`组成的 😳<br> 
> `系统调用` = `广义指令` 😪

3.对硬件扩展

### 操作系统四大特征
`并发`和`共享`(两个基本，互为条件)， `虚拟`, `异步`
> 并发(concurrency)：多个事件在同一时间`间隔`发生。宏观上(逻辑上)同时发生，微观上(物理上)交错发生 <br>
> 并行(parallelism)：多个时间在同一时间`同时`（物理上）发生。 `那是说要多核了啊，对一个核而言只处理一件事`🤣

+ `并发`：允许多个程序在(交替或并行)运行，即`多道程序技术` 
+ `共享`：互斥共享(独占资源)、(宏观上)同时共享 
+ `虚拟`：物理实体对应到逻辑实体： 比如空分复用(虚拟内存)、时分复用(虚拟CPU搞并发)
+ `异步`：有多个程序并发的时候，对于程序的小片段相对另一个程序来说执行顺序不可预先确定。可以阻塞、可以释放

> 因为业务上有太多时间容忍度很小的事件。事件驱动

### 操作系统的历史
+ 手工操作阶段：纸带机, 用户独占全机、人机速度矛盾导致资源利用率低
+ 单道批处理阶段： 磁盘机+外围机，脱机输入输出，`监督程序`（操作系统雏形）控制I/O :只能串行、大量IO阻塞
+ 多道批处理阶段：交替执行，引入`中断`功能(IO与计算之间可以不相互阻塞了，设备间并行了)，`操作系统诞生`😥。：虽然能并发，但是没法人机`交互`，你要等他这个程序跑完或报错
+ 分时操作系统：时间片轮流服务，那么轮到你的时间片的时候就可以`交互`了，你可以告诉他我这个程序要关掉：但是时间片是公平的，不能`优先处理紧急任务`
+ 实时操作系统：`紧急任务`的时间片可以"插队"，更加及时可靠。比如导弹的硬实时系统、而软实时系统的紧急事件等一等也没事
+ 网络操作系统、分布式操作系统、个人计算机操作系统



### 操作系统运行机制和架构

> `指令` 和`代码`的区别？ C语言代码可能翻译成多条机器语言 (二进制)指令，可以被CPU 具体识别。
+ 特权指令：不允许用户程序使用。比如内存清零指令、访问硬件等。
+ 非特权指令：比如普通的运算。

> PSW(程序状态字寄存器)中某个标志位表示CPU状态。
+ CPU处于`用户态`时只能执行非特权指令。
+ CPU处于`核心态`时都可以执行。

> (普通)`应用程序`为了安全，只能用非特权指令。 比如记事本、任务管理器，不是内核功能。

> `内核`(内核程序) 可以执行两种指令，运行在核心态。因此，用了核心态的功能的程序就是内核程序。 比如时钟管理、原语程序(具有原子性，即要么执行要么不执行)、中断处理程序。

> 有的操作系统把进程管理、存储器管理、设备管理也算内核。(如果算，就称为`宏内核`， 否则就是`微内核`)

> `宏内核`：代码庞大、性能高；`微内核`：代码少，需要频繁在核心态和用户态之间切换。


### (外)中断和(内中断)异常
> 解决资源串行利用率低的问题。需要中断来并发执行。

> CPU收到计时部件的`中断信号`，（立刻）切换为`核心态`,让操作系统介入管理,操作系统会对不同的信号做不同处理。

> 从用户态→核心态只能通过中断实现。而核心态→用户态只需要改PSW。

> 外中断：外设请求、人工干预。(信号来自CPU外部)

> 内中断(异常、例外、陷入)：自愿中断(指令中断)，强迫中断(硬件故障，比如缺页、软件中断，比如除0)。


### 系统调用
> 为什么提供系统调用？ 避免每个进程随意使用资源、需要OS进行协调管理一些公共的函数， 保证稳定性和安全性。
一般需要特权指令、在核心态下完成

+ 设备：请求/释放/启动
+ 文件：读/写/创建/删除
+ 进程: 创建/撤销/阻塞/唤醒/信号传递/信息传递
+ 内存: 分配/回收


### 进程

程序：一个指令序列。<br>
`进程`(Process):`资源分配的基本单元`， 被CPU调度的单元，就是程序的一次执行。 `进程实体`由程序段、数据段、PCB组成。PCB是进程唯一存在标志。<br>
`线程`(Thread):`CPU调度的基本单元`。 

> PCB(进程控制块):里面会有记各个寄存器的值，下次轮到执行时可以恢复。进程本身是动态的，进程实体里存了静态的数据。

> 操作系统的`执行指针`：指向当前执行的PCB;`就绪表指针`，指向就绪PCB列表；`阻塞表指针`，指向阻塞的PCB列表。

进程特征：
+ 动态性
+ 并发性： 并发结果会不确定。需要操作系统提供`进程同步`来保证。
+ 独立性
+ 异步性
+ 结构性

#### 进程的状态转化

三种基本状态：(看拥有的资源可以知道是什么状态)
+ 运行态(Running)：独占CPU(一个核)
+ 就绪态(Ready):具备运行条件，`只差CPU`
+ 阻塞态(Blocked/Waiting):还差`其他资源/事件`条件，暂时不能运行

两种额外状态：
+ 创建态： 正在分配资源，初始化PCB
+ 终止态： 正在回收资源，销毁PCB

转换：
+ 创建态 → 就绪态 → 运行态
+ 运行态 → 就绪态：时间片到、或被抢占
+ 运行态 → 阻塞态：（主动）“系统调用”等待资源、等待事件
+ 阻塞态 → 就绪态：（被动）资源好了，等待CPU
> 不能阻塞态直接到运行态的，也不能就绪态到阻塞态的 （书上是这么说）

#### 进程控制：就是实现进程状态转换
PCB用于保存/恢复进程环境、记录标志位、排队<br>
用`原语`(即`原子操作`，只能一气呵成，需要运行在`核心态`)实现控制.先`关中断`，完成后`开中断`实现了原子操作，外部中断信号会被临时屏蔽。
<br>原语做三件事：更新PCB、插PCB到合适队列、分配/回收资源。
+ 进程创建(创建原语)：用户登录、作业调度、提供服务、应用请求(子进程)
+ 进程终止(撤销原语):正常结束、异常结束(比如div 0)、外界干预
+ 进程阻塞(阻塞原语)：等待资源(比如IO)、等待其他进程
+ 进程唤醒(唤醒原语): 等待的事件(被阻塞的事件)发生


#### 进程通信：进程间交换信息
进程是分配资源的基本单位，(为了安全)各进程的内存空间独立(不能直接相互访问)
+ `共享存储`：(互斥的访问，操作系统提供PV)共享空间：包括`共享存储结构`、`共享存储区`(速度更快)
+ `管道通信`：基于(互斥的)共享文件，即在内存中开辟缓冲区。管道只能`半双工`(一个时间内单向)。可以做两个管道同时两个方向。
管道满了后write()要等待读进程的read()，空了等write()。没写满不能读，没读空不嫩写。一旦取出就没了，`因此只能被一个进程读`。
+ `消息传递`：通过`格式化的消息`(消息头+消息体)，操作系统提供发送原语/接收原语。直接通信，可以直接挂在接收进程的消息缓重队列。间接通信，需要通过中间的信箱。

### 线程
“线程”增加进程内的并发度，成了`程序执行的最小单元`（`CPU调度基本单位`），进程内可以改变执行流。
+ 线程是CPU调度的单位
+ 各个线程可占用不同CPU
+ 每个线程有线程ID、线程控制块TCB
+ 线程也有就绪、阻塞、运行三种基本状态
+ 线程几乎不拥有系统资源
+ 同一进程的不同线程间共享进程资源(进程是最小资源分配单元)
+ 因为进程内共享内存地址空间，无需OS干预就可以进程内通信
+ 切换进程内的线程系统开销较小(而进程切换开销大)

<br>用户级线程(User-Level Thread, ULT, 即Green Thread)：由应用程序管理，线程切换在`用户态`完成。用户看到是多线程(可以多个同时映射到内核线程上)、操作系统只看到了一个进程。
<br>内核级线程(Kernel-Level Thread, KLT):内核支持管理的线程。操作系统看的到，需要在`内核态`切换。
> `内核级线程`才是CPU调度单位。不然就是用户程序自己调度。
+ 多对一模型：并发度不高，可能会卡在一个用户级线程，因为都去使用内核线程。
+ 一对一模型：单个进程占了多个内核，卡住概率低，要在核心态切换，开销大。
+ 多对多模型：n >= m。比上面两种合理。

### 调度问题
+ 先到先服务
+ VIP优先
+ 时间短优先

<br>(高级调入)作业调度：从作业列表选出作业，由外存调入内存、建立PCB进程。频率低。
<br>(中级调度)内存调度(进入`进程挂起状态`，即挂起队列。阻塞态的进程也可以进挂起)：暂时不能运行的调入虚拟内存(外存)与调回。提高内存利用率和系统吞吐量。
<br>(低级调度)进程调度：频率高，一般几十毫秒。

<br>什么时候需要进程调度？
+ 主动放弃处理机(CPU)
+ 被动放弃：时间片用完、紧急事情、更高优先级进程进入
<br>什么时候不能进程调度或切换？
+ 做中断处理时
+ 在原子操作过程中
+ 进程在操作系统`内核程序临界区`(不是普通临界区)中。
> 临界资源：互斥访问的资源。临界区：访问临界资源的代码。内核临界区：访问某种内核数据结构的代码，比如访问进程的就绪队列。
<br>调度方式
+ `非抢占式`。(非剥夺式)，只能等他自己结束，主动放弃处理机，然后其他任务可能被分配。😪现代OS，那这种东西没用啊
+ `抢占式`。(剥夺式)，紧急任务可以抢用

#### 调度算法的指标
+ CPU利用率(CPU认为是最重要的资源)：忙碌/总时间。
+ 吞吐量：完成作业数/总共时间(秒)。
+ 周转时间：(平均)作业提交开始导作业完成为止的时间间隔。
+ 带权周转时间： (平均)周转时间除以实际运行时间。(本来就是那么多时间，你却花了额外的时间排队、切换)
+ 响应时间：提交请求首次被回应的时间。

#### 调度算法
算法思想、算法规则、是作业调度还是进程调度、是否抢占式、优缺点、是否饥饿(某作业一直不能服务)
> 早期批处理算法：这3种没用，因为用户无法交互，不能设权重。
+ FCFS (First Come First Serve 先来先服务)。
"公平"服务、非抢占、谁先来谁先服务。缺点：对于排在`长作业`后的`短作业` 体验不好，对长作业有利。不会饥饿。
+ SJF (Short Job First 短作业优先)。
多作业/进程优先。可以做抢占式的。优点：短作业有利，长作业不利。可能长作业会饥饿。
+ HRRN (Highest Response Ratio Next)。
综合考虑等待时间和服务时间，响应比高的优先。 响应比= (等待时间+要求服务时间) / 要求服务时间。非抢占的。不会饥饿。
> 后来的算法
+ RR(Round-Robin, 时间片轮转)。公平轮转的让各个进程执行一个CPU时间片(100ms可能，也可能动态的)。是(时钟中断)抢占式的。响应快，但是切换开销大，需要设计好时间片。不会饥饿，但是吃不饱。
+ 优先级调度算法：可以抢占式或者不抢占式。可以实现紧急任务。会饥饿。
+ 多级反馈队列调度算法：综合上面的算法，复杂，多个优先级的队伍，可以降级。一般用于进程调度，可以抢占式的。会饥饿。

